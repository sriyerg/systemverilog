# SV Config

This example showcases the use of SV config to push the decision of how to
compose the top level to elaboration time, rather than file list generation
time.

Open source build systems such as [FuseSoC](https://github.com/olofk/fusesoc)
currently are limited to generating a single dependency-resolved file list that
is then presented to the underlying simulator / EDA tool to be compiled and
elaborated. This is problematic in complex HW projects such as OpenTitan, which
require advanced modes to be supported such as being able to swap out a module
definition with a custom implementation, where the custom implementation may be
maintained in a separate location.

The industry has already solved this problem with SystemVerilog config - a
custruct which has been a part of the SV 1800-2001 LRM standard. It allows the
compilation of design (and testbench) sources into separate libraries. At
elaboration time, the SV config tells the tool what the preference order is,
when searching for module definitions compiled into those libraries. Different
implementations of the same module can co-exist, as long as they are compiled
into separate libraries. The EDA tool then chooses the right module based on the
library preference order. For specific modules or instances, the library
preference order can be overridden as well. The constructs used for these is
described in SV 1800-2017 Chapter 33.

In this example, the adjoining `sysnopsys_sim.setup` defines 4 libraries - `ip`,
`system`, `vendor` and `dv`. By default, if sources are not compiled into one of
these libraries, they get compiled into the `work` library, which has the lowest
preference. The `Makefile` follows a 3-step simulation process - compile,
elaborate and simulate using Synopsys VCS. In the compilation stage, it compiles
sources set in individual file lists into their own libraries. These file lists
are hand-written, but they would be auto-generated by higher level build systems.
The contents of each of those file lists are described below.

A simple module `foo` is defined at the IP level and is located at `hw/ip/foo`.
It instantiates a sub-module `bar`. These do not do anything, other than set a
string and print it. The value of the string depends on parameters defined in
the adjoining `foo_pkg`. These sources are compiled into the `ip` library.

Module `foo` is re-defined for the top level at `hw/top/ip/foo`. `foo_pkg` is
also re-defined to reflect the values for the top-level. `foo` design is kept
the same as the IP version, except that it instantiates a new sub-module `baz`.
The module `bar` is not re-defined, so during elaboration, the flow should pick
up its definition from the `ip` library. Finally, `foo` is instantiated in `top`
located at `hw/top`. These top-level-specific sources are compiled into the
`system` library.

An alternate version of `baz` is defined in `hw/foundry`, to mimic the usecase
where an existing generic version of a design needs to be swapped with a custom,
proprietary version. None of the other modules are re-defined, so those
definitions must be picked up from the `system` library first, followed by the
`ip` library.

The testbench `hw/ip/foo/foo_tb.sv` verifies the correctness of the the
instantiation of `foo` module at the IP level. For the top-level, this is done
by `hw/top/top_tb.sv`. For the sake of simplicity, these testbenches are put in
the same file list `dv.f` and are compiled into the `dv` library. In theory,
that wouldn't be the case - there will generally be only one testbench compiled
for a given DUT.

Finally, in `hw/configs`, 3 different flavors of our design compositions are
made - `ip_cfg`, `system_cfg` and `foundry_cfg`, placed at `hw/configs`. Again,
these may no co-exist in the same directory in a real system; it is done here
just for illustration. These are compiled into the default `work` library. These
currently only set the top level design and the liblist preference order. In
theory, the library preference order can be overridden for an entire module or
specific instances of a module to choose a different implementation, using
`cell` and `instance` directives.

Note that the sources in these file lists do have dependencies on each other,
but they are required to be specified during the compilation stage. Also, the
config flavors are compiled as totally disjoint entity, without being dependent
on anything either. This makes it super flexible for an entity to create their
own config and swap out an existing definition of a module with their own
implementation. For each flavor, the corresponding config is specified as the
top level entity that needs to be elaborated.

Each of these configs can be simulated with the following command:
```console
$ make made=<flavor>
```

Where `<flavor>` is either `ip`, `system` or `foundry`.
